#version 430
uint GRROUP_SIZE = 20;
layout (local_size_x = 20, local_size_y = 1, local_size_z = 1) in;


int currentEdgeIteration = 0;
float SPEED_DIVISOR = 800;
float AREA_MULTIPLICATOR = 10000;
float speed = 1;
float area = 1000;
float gravity = 10;

struct GraphicData
{
    vec4 position;
    vec4 color;
    float size;
    float dx;
    float dy;
    float dz;
};

struct Connections
{
    int from;
    int to;
};

layout (std430, binding = 0) buffer DataBuffer 
{
	GraphicData data[];
};

layout (std430, binding = 8) buffer DataConnections
{
	Connections connections[];
};

layout( location = 1 ) uniform int graphDataSize;
layout( location = 9 ) uniform int connectionSize;

void main(void)
{
    float maxDisplace = (sqrt(AREA_MULTIPLICATOR * area) / 10.0);
    float k = ((AREA_MULTIPLICATOR * area) / (1.0 + graphDataSize));

    uint index = gl_GlobalInvocationID.x;

    uint minsize =  index * GRROUP_SIZE;
    uint maxSize = (index * GRROUP_SIZE) + GRROUP_SIZE;

    for(uint i = minsize; i < maxSize; i++ )
    {
        data[i].dx = 0;
        data[i].dy = 0;
        data[i].dz = 0;

        for (uint j = minsize; j < maxSize; j++)
        {
            if (i != j)
            {
                float xDist = data[i].position[0] - data[j].position[0];
                float yDist = data[i].position[1] - data[j].position[1];
                float zDist = data[i].position[2] - data[j].position[2];
                float dist = sqrt(xDist * xDist + yDist * yDist + zDist * zDist);
                float repulsive = (k * k) / dist;
                data[i].dx += xDist / dist * repulsive;
                data[i].dy += yDist / dist * repulsive;
                data[i].dz += zDist / dist * repulsive;
            }
        }
    }

    for (int i = 0; i < connectionSize; i++)
    {
        GraphicData source = data[connections[i].from];
        GraphicData target = data[connections[i].to];

        float xDist = source.position[0] - target.position[0];
        float yDist = source.position[1] - target.position[1];
        float zDist = source.position[2] - target.position[2];
        float dist = sqrt(xDist * xDist + yDist * yDist + zDist * zDist);

        if (dist > 0)
        {
            float atractive = (dist * dist) / k;
            source.dx -= xDist / dist * atractive;
            source.dy -= yDist / dist * atractive;
            source.dz -= zDist / dist * atractive;

            target.dx += xDist / dist * atractive;
            target.dy += yDist / dist * atractive;
            target.dz += zDist / dist * atractive;

            data[connections[i].from] = source;
            data[connections[i].to] = target;
        }
    }

    for (uint i = minsize; i < maxSize; i++)
    {
        GraphicData pos = data[i];
        float d = sqrt((pos.position[0] * pos.position[0] + pos.position[1] * pos.position[1] + pos.position[2] * pos.position[2]));
        float gf = 0.01 * k * gravity * d;

        pos.dx -= gf * pos.position[0] / d;
        pos.dy -= gf * pos.position[1] / d;
        pos.dz -= gf * pos.position[2] / d;

        pos.dx += speed;
        pos.dy += speed;
        pos.dz += speed;

        d = sqrt((pos.dx * pos.dx + pos.dy * pos.dy + pos.dz * pos.dz));

        if (d > 0)
        {
            float limitedDist = min(maxDisplace * (speed / SPEED_DIVISOR), d);
                            
            pos.position[0] = pos.position[0] + pos.dx / d * limitedDist;
            pos.position[1] = pos.position[1] + pos.dy / d * limitedDist;
            pos.position[2] = pos.position[2] + pos.dz / d * limitedDist;
        }
        data[i] = pos;
    }

}

// void App::Fruchterman_Reingold()
// {

//     auto edgeSize = fromToConnectionIndex.size();


//     // edgeSize = (*connections).size();
//     for (int i = 0; i < fromToConnectionIndex.size(); i++)
//     {
//         auto source = (*nodesData)[fromToConnectionIndex[i].from];
//         auto target = (*nodesData)[fromToConnectionIndex[i].to];

//         (*edgesData).push_back(source);
//         (*edgesData).push_back(target);
//     }
//     nodes.AddInstanced(nodesData);
//     edges.AddInstanced(edgesData);
// }