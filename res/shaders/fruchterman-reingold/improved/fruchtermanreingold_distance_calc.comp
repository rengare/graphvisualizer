#version 430
#define GROUPSIZE 256

layout (local_size_x = GROUPSIZE) in;

float AREA_MULTIPLICATOR = 1000.0;

layout( location = 12 ) uniform float area = 100.0;
layout( location = 17 ) uniform int graphType3d = 0;

struct GraphicData
{
    vec4 position;
    vec4 color;
    float size;
    float dx;
    float dy;
    float dz;
};

struct Connections
{
    int from;
    int to;
};

layout (std430, binding = 0) buffer DataBuffer 
{
	GraphicData data[];
};

layout (std430, binding = 8) buffer DataConnections
{
	Connections connections[];
};

layout( location = 1 ) uniform int graphDataSize;

vec3 distance(vec4 currentPosition, vec4 cachedPosition){
    return currentPosition.xyz - cachedPosition.xyz;
}

vec3 repulsion(vec4 currentPosition, vec4 cachedPosition, float k){
    vec3 dist = distance(currentPosition, cachedPosition);
    if(graphType3d == 0) dist.z = 0;
    float distSqrt = sqrt(dist.x * dist.x + dist.y * dist.y + dist.z * dist.z);
    float repulsive = k / distSqrt;
    
    return (dist / distSqrt * repulsive);
}

void main(void)
{
    float k;
    uint globalIndex = gl_GlobalInvocationID.x;
    
    uint N = gl_NumWorkGroups.x*gl_WorkGroupSize.x;
    
    if(globalIndex > graphDataSize) return;

    GraphicData currentModel = data[globalIndex];
    
    k = ((AREA_MULTIPLICATOR * area) / (1.0 + graphDataSize));
    k = k * k;

    vec3 t = vec3(0.0);
    for (uint j = 0; j < graphDataSize; j++)
    {
        
        if (globalIndex != j)
        {
            t += repulsion(currentModel.position, data[j].position, k);   
        }
    }
    
    currentModel.dx = t.x;
    currentModel.dy = t.y;
    currentModel.dz = t.z;
    data[globalIndex] = currentModel;
}