#version 430
layout (local_size_x = 10, local_size_y = 1, local_size_z = 1) in;

float SPEED_DIVISOR = 800.0;
float AREA_MULTIPLICATOR = 1000.0;

layout( location = 11 ) uniform float speed = 100.0;
layout( location = 12 ) uniform float area = 100.0;
layout( location = 13 ) uniform float gravity = 10.0;

struct GraphicData
{
    vec4 position;
    vec4 color;
    float size;
    float dx;
    float dy;
    float dz;
};

struct Connections
{
    int from;
    int to;
};

layout (std430, binding = 0) buffer DataBuffer 
{
	GraphicData data[];
};

layout (std430, binding = 8) buffer DataConnections
{
	Connections connections[];
};

layout (std430, binding = 15) buffer RepulsiveBuffer 
{
	vec4 repulsiveDistances[];
};

layout( location = 1 ) uniform int graphDataSize;
layout( location = 9 ) uniform int connectionSize;

void syncronize()
{
	memoryBarrierShared();
	barrier();
}

void main(void)
{
    float maxDisplace = (sqrt(AREA_MULTIPLICATOR * area) / 10.0);
    float k = ((AREA_MULTIPLICATOR * area) / (1.0 + graphDataSize));

    uint globalIndex = gl_GlobalInvocationID.x;
    
    if(globalIndex > graphDataSize) return;

    vec3 calculatedDistance = vec3(0) ;

    for (uint j = 0; j < graphDataSize; j++)
    {
        if (globalIndex != j)
        {
            float xDist = data[globalIndex].position[0] - data[j].position[0];
            float yDist = data[globalIndex].position[1] - data[j].position[1];
            float zDist = data[globalIndex].position[2] - data[j].position[2];
            float dist = sqrt(xDist * xDist + yDist * yDist + zDist * zDist);
            float repulsive = (k * k) / dist;
            

            calculatedDistance.x += xDist / dist * repulsive;
            calculatedDistance.y += yDist / dist * repulsive;
            calculatedDistance.z += zDist / dist * repulsive;
        }
    }

    data[globalIndex].dx = calculatedDistance.x;
    data[globalIndex].dy = calculatedDistance.y;
    data[globalIndex].dz = calculatedDistance.z;
}