#version 430
layout (local_size_x = 10, local_size_y = 1, local_size_z = 1) in;


int currentEdgeIteration = 0;
float SPEED_DIVISOR = 800;
float AREA_MULTIPLICATOR = 1000;
float speed = 10;
float area = 10000;
float gravity = 10;

struct GraphicData
{
    vec4 position;
    vec4 color;
    float size;
    float dx;
    float dy;
    float dz;
};

struct Connections
{
    int from;
    int to;
};

layout (std430, binding = 0) buffer DataBuffer 
{
	GraphicData data[];
};

layout (std430, binding = 8) buffer DataConnections
{
	Connections connections[];
};

layout( location = 1 ) uniform int graphDataSize;
layout( location = 9 ) uniform int connectionSize;

shared vec4 localPositions[ gl_WorkGroupSize.x ];

void syncronize()
{
	memoryBarrierShared();
	barrier();
}

void main(void)
{
    float maxDisplace = (sqrt(AREA_MULTIPLICATOR * area) / 10.0);
    float k = ((AREA_MULTIPLICATOR * area) / (1.0 + graphDataSize));

    uint globalIndex = gl_GlobalInvocationID.x;
    uint localIndex =  gl_LocalInvocationID.x;
    
    if(globalIndex > graphDataSize) return;

    GraphicData pos = data[globalIndex];
    float d = sqrt((pos.position[0] * pos.position[0] + pos.position[1] * pos.position[1] + pos.position[2] * pos.position[2]));
    float gf = 0.01 * k * gravity * d;

    pos.dx -= gf * pos.position[0] / d;
    pos.dy -= gf * pos.position[1] / d;
    pos.dz -= gf * pos.position[2] / d;

    pos.dx += speed;
    pos.dy += speed;
    pos.dz += speed;

    d = sqrt((pos.dx * pos.dx + pos.dy * pos.dy + pos.dz * pos.dz));

    if (d > 0)
    {
        float limitedDist = min(maxDisplace * (speed / SPEED_DIVISOR), d);
                        
        pos.position[0] = pos.position[0] + pos.dx / d * limitedDist;
        pos.position[1] = pos.position[1] + pos.dy / d * limitedDist;
        pos.position[2] = pos.position[2] + pos.dz / d * limitedDist;
    }
    data[globalIndex] = pos;
}